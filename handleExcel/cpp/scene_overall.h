/*
*
* Copyright 2016
* All rights reserved.
* This file is automatically generated by python script of which 
* the author is wupeng.
*
*/

#include <lib_file_tab_txt.h>
#include <lib_util.h>

namespace scene_overall_auto{
	struct channel_type_t{
		uint16_t map_id;
		uint32_t x;
		uint32_t y;
	};

	struct scene_overall_cfg_t
	{
		std::string name;		//地图名称	
		uint32_t avatar;		//场景形象ID	
		std::vector<std::vector<uint32_t>> liiimit_hei;
		std::vector<uint32_t> limit_wu;
		uint8_t x;		//场景通道类型	
		uint32_t y;		//场景通道类型	
		uint32_t z;		//场景通道类型	
		std::vector<channel_type_t> hello_channels;
		std::vector<channel_type_t> from_channels;
		std::vector<channel_type_t> example_channel;

		void load(el::lib_file_tab_txt_t& file_tab_txt, std::vector<std::string>& ref){
			std::string __str_def__;

			this->name= file_tab_txt.get_val_def("name", ref, __str_def__);
			this->avatar= file_tab_txt.get_val_def("avatar", ref, 0);
			{
				std::string array = file_tab_txt.get_val_def("liiimit_hei", ref, __str_def__);
				this->liiimit_hei = el::g_cat_string<uint32_t>(array, ';', '_');
			}
			{
				std::string array = file_tab_txt.get_val_def("limit_wu", ref, __str_def__);
				el::g_cat_string<uint32_t>(this->limit_wu, array, '_');
			}
			{
				std::string str_array = file_tab_txt.get_val_def("from_channels", ref, __str_def__);
				auto para_vec = el::g_cat_string<std::string>(str_array, ';', '_');

				FOREACH(para_vec, it){
					channel_type_t channel_type;
					std::vector<std::string>& u_vec = *it;
					el::convert_from_string(channel_type.map_id, u_vec[0]);
					el::convert_from_string(channel_type.x, u_vec[1]);
					el::convert_from_string(channel_type.y, u_vec[2]);
					this->from_channels.push_back(channel_type);
				}
			}
			{
				std::string str_array = file_tab_txt.get_val_def("hello_channels", ref, __str_def__);
				auto para_vec = el::g_cat_string<std::string>(str_array, ';', '_');

				FOREACH(para_vec, it){
					channel_type_t channel_type;
					std::vector<std::string>& u_vec = *it;
					el::convert_from_string(channel_type.map_id, u_vec[0]);
					el::convert_from_string(channel_type.x, u_vec[1]);
					el::convert_from_string(channel_type.y, u_vec[2]);
					this->hello_channels.push_back(channel_type);
				}
			}
			{
				std::string str_array = file_tab_txt.get_val_def("example_channel", ref, __str_def__);
				auto para_vec = el::g_cat_string<std::string>(str_array, ';', '_');

				FOREACH(para_vec, it){
					channel_type_t channel_type;
					std::vector<std::string>& u_vec = *it;
					el::convert_from_string(channel_type.map_id, u_vec[0]);
					el::convert_from_string(channel_type.x, u_vec[1]);
					el::convert_from_string(channel_type.y, u_vec[2]);
					this->example_channel.push_back(channel_type);
				}
			}
			this->x= file_tab_txt.get_val_def("x", ref, 0);
			this->y= file_tab_txt.get_val_def("y", ref, 0);
			this->z= file_tab_txt.get_val_def("z", ref, 0);		
		}
	};
}
