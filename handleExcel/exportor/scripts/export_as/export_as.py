# encoding=utf8
import os
import struct
import sys
import json
import string
import ParseXls

reload(sys)  
sys.setdefaultencoding('utf8')

XLS_DIR=""
AS_DIR=""

def initPath():
	global XLS_DIR
	global AS_DIR
	XLS_DIR = sys.argv[1]
	AS_DIR = sys.argv[2]

class GenerateAsFromDat:
	def generate(self, xlsFileName):
		xlsFilePathName = XLS_DIR + xlsFileName
		if os.path.isfile(xlsFilePathName) == False:
			raise  Exception("file does not exist!")
		print xlsFileName
		parseXls = ParseXls.ParseXls(xlsFilePathName, AS_DIR)	
		
		lst = [word[0].upper() + word[1:] for word in parseXls.staitcFileName.split()]
		parseXls.staitcFileName = ''.join(lst)
		parseXls.staitcFileName = self.beautifyFormation(parseXls.staitcFileName)
		#print parseXls.staitcFileName
		staticdataLiteral = ''
		if os.name == 'nt':
			#windows system
			staticdataLiteral = '\\staticdata\\'
		else:
			#unix or linux system
			staticdataLiteral = '/staticdata/'

		if not os.path.exists(AS_DIR + staticdataLiteral):
			os.makedirs(AS_DIR + staticdataLiteral)
		
		if parseXls.staitcFileName == '':
			print "xlsFileName = ", xlsFileName
			raise  Exception("file name is nil!")
		asFilePathName = AS_DIR + staticdataLiteral  + parseXls.staitcFileName + ".as"
		if os.path.isfile(asFilePathName):
			os.remove(asFilePathName)
		asFile = file(asFilePathName, "wb")

		classStr = "public class"
		extendsStr = "StaticInfoBase"
		if (parseXls.staitcFileName == "PlayerInfo"):
			extendsStr = "StaticInfoBase"

		contentStr = '''/*
*
* Copyright 2016
* All rights reserved.
* This file is automatically generated by python script of which 
* the author is wupeng.
*
*/
'''
		contentStr += "package staticdata\n{\n" + "\t" + \
				"import flash.utils.ByteArray;\n\t"  + "import staticdata.define.*" + "\n\n"
		contentStr += "\t" + classStr + " " + parseXls.staitcFileName + " extends " + extendsStr + "\n\t{\n"
		
		colSize = parseXls.getColSize()
		for i in range(0, colSize):
			typeStr = parseXls.getType(i)
			nameStr = parseXls.getName(i)
			descStr = parseXls.getDesc(i).replace('\n','')
			
			if typeStr.find('array~') == 0:
				continue
			typeStr = self.getRepairedType(typeStr.lower())
	
			contentStr += "\t\t" + "public var " + self.beautifyFormation(nameStr) + ":" + typeStr + ";" + "\t\t//" + descStr + "\n"

		for relativeVariableName, relativeClassName in parseXls.mapClass.iteritems():  #for python 2.x
			contentStr += "\t\tpublic var " + self.beautifyFormation(relativeVariableName) + ":Vector.<" +  self.beautifyFormation(relativeClassName) + ">;\t\n"
			
			
		contentStr += "\n\t\t" + "public function " + parseXls.staitcFileName + "(data:ByteArray)\n\t\t{\n" + \
				"\t\t\t" + "super(data);\n"

		readStr = "data.readUTF();"
		for i in range(0, colSize):
			readStr = "data.readUTF();"
			typeStr = parseXls.getType(i)
			nameStr = parseXls.getName(i)
			descStr = parseXls.getDesc(i)

			readStr = self.getResolveFunction(typeStr.lower())
			#whetherContinue = False
			if typeStr.find('array~') == 0:
				className = self.extractClassName(typeStr)
				for relativeVariableName, relativeClassName in parseXls.mapClass.iteritems():  #for python 2.x
					if nameStr == relativeVariableName:
						classInfo = self.getSpecificClassInfo(parseXls, relativeClassName)
						contentStr += "\t\t\t" + self.beautifyFormation(relativeVariableName) + " = " + "new Vector.<" + classInfo.className + ">();\n"
						contentStr += "\t\t\tvar l:int = data.readUnsignedByte();\n"
						iString = ''
						if contentStr.find("var i:int = 0;") >=0:
							iString = 'i = 0; '
						else: 
							iString = "var i:int = 0; "
						contentStr += "\t\t\tfor(" + iString +  "i < l; i++)\n\t\t\t{\n"
						tempClassName = "each" + classInfo.className
						contentStr += "\t\t\t\tvar " + tempClassName + " : " + classInfo.className + " = new " + classInfo.className + "();\n"	
						for i in range(len(classInfo.variablesList)):
							typeList = classInfo.typeList
							readStr = self.getResolveFunction(typeList[i].lower())
							contentStr += "\t\t\t\t" + tempClassName + '.' + classInfo.variablesList[i] + " = " + readStr + "\n"
						contentStr += "\n\t\t\t\t" + self.beautifyFormation(relativeVariableName) + ".push(" + tempClassName + ");\n\t\t\t}\n\n"
						whetherContinue = True
			#			break
			#elif whetherContinue:
			#	continue
			elif typeStr == 'intarray2':
				contentStr += '''
			var array:Array = data.readUTF().split(";");
			for (var i:int = 0; i < array.length; i++)
			{
				'''
				contentStr += self.beautifyFormation(nameStr)
				contentStr +=".push(array[i].split(\"_\"));\n\t\t\t}\n\n"
			elif typeStr == 'intarray' or typeStr == 'bytearray':
				contentStr += '\t\t\t' + self.beautifyFormation(nameStr) + ' = ' + readStr + '\n'
			else:
				contentStr += "\t\t\t" + self.beautifyFormation(nameStr) + " = " + readStr + "\n"
				
		contentStr = contentStr.strip('\n')
		contentStr += "\t\t\n\t\t}\n" + "\t}\n" + "}\n"
		asFile.write(contentStr)
		asFile.close()
		
	def extractClassName(self, rawString):
		classNamePositin = rawString.find('~') + 1
		className = []
		for i in range(classNamePositin, len(rawString)):
			if (ord(rawString[i]) == 95) or ((ord(rawString[i]) >= 48) and (ord(rawString[i]) <=57)) or ((ord(rawString[i]) >= 65) and (ord(rawString[i]) <=90))  or ((ord(rawString[i]) >= 97) and (ord(rawString[i]) <=122)):
				className.append(rawString[i])
			else:
				break
		lst = [word[0].upper() + word[1:] for word in ''.join(className).split()]
		stringClassName = " ".join(lst)
		stringClassName = self.beautifyFormation(stringClassName)		
		return stringClassName
		
	def getRepairedType(self, rawString):
		if (rawString == "byte"):
			return "int"
		elif (rawString == "int"):
			return "int"
		elif (rawString == "string"):
			return "String"
		elif (rawString == "short"):
			return "int"
		elif (rawString == "float"):
			return "Number"
		elif (rawString == "intarray") or (rawString == "bytearray"):
			return "Array"
		elif (rawString == "intarray2") :
			return "Array = []"
	def getResolveFunction(self, rawString):
		if (rawString == "int"):
			return "data.readUnsignedInt();"
		elif (rawString == "byte"):
			return "data.readUnsignedByte();"
		elif (rawString == "short"):
			return "data.readUnsignedShort();"
		elif (rawString == "string"):
			return "data.readUTF();"
		elif (rawString == "float"):
			return "data.readFloat();"
		elif (rawString == "intarray") or (rawString == "intarray2") or (rawString == "bytearray"):
			return "data.readUTF().split(" + "\"_\"" + ");"
	def getSpecificClassInfo(self, parseXls, className):
		for classInfo in parseXls.classList:
			if classInfo.className == className:
				return classInfo
		return ''
		
	def beautifyFormation(self, nameStr):
		indices = set([])
		for i,c in enumerate(nameStr):
			if "_"==c: indices.add(i+1)
		if (len(indices) == 0):
			return nameStr
		nameStr = "".join(c.upper() if i in indices else c for i, c in enumerate(nameStr))
		nameStr = nameStr.replace('_','')
		return nameStr
	def pause(self):
		raw_input_A = raw_input("Generate successfully! Press any key to exit!")
		
initPath()
generater = GenerateAsFromDat()
#generater.generate(u"场景总表")
#不要写文件格式，比如.xls
generater.generate(u"场景总表.xls")  
#generater.pause()
