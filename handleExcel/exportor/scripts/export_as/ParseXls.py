# encoding=utf8
import struct
import re
import os
import sys
import xlrd
import time


reload(sys)  
sys.setdefaultencoding('utf8')

class ParseXls:
	def __init__(self, xlsFullPathName, destinationDir):
		self.xlsFullPathName = xlsFullPathName
		self.destinationDir = destinationDir
		self.staitcFileName = ''
		self.colSize = 0
		self.rowSize = 0
		self.type = []
		self.name = []
		self.desc = []
		self.classList = []
		self.mapClass = {}
		
		workbook = xlrd.open_workbook(self.xlsFullPathName)
		worksheet = workbook.sheet_by_index(0)
		row1 = self.ConvertValue(worksheet.row_values(0))
		row2 = self.ConvertValue(worksheet.row_values(1))
		row3 = self.ConvertValue(worksheet.row_values(2))
		row4 = self.ConvertValue(worksheet.row_values(3))
		row5 = self.ConvertValue(worksheet.row_values(4))
		
		self.excludeRepeatedCase(row5)
		
		if row1[0] == '':
			errStr = '!!!!!!!! ', 'File name is nill!', ' !!!!!!!!!!'
			print errStr
			time.sleep(1000)
			raise Exception(errStr)
		self.staitcFileName = row1[0]
		
		for i in range(len(row2)):
			if row2[i] == "1":
				strName = row4[i].lower()
				#if strName == "intarray" or strName == "intarray2":
				#	strName = "String"
				self.excludeBlankData(row4[i], 4) 
				self.excludeBlankData(row5[i], 5) 
				
				if self.isSplitCase(strName):
					typeList = strName.split(';')
					variablesList = row5[i].split(';')
					if len(typeList) != len(variablesList):
						errStr = '!!!!!!!! ', 'encounter error here. mark 1', ' !!!!!!!!!!'
						print errStr
						time.sleep(1000)
						raise Exception(errStr)
					for j in range(len(typeList)):
						self.type.append(typeList[j])
						self.name.append(variablesList[j])
						self.desc.append(unicode(row3[i], 'gbk'))
				else:
					self.type.append(strName)
					self.name.append(row5[i])
					self.desc.append(unicode(row3[i], 'gbk'))
		self.colSize = len(self.type)
		self.rowSize = worksheet.nrows - 5
			
		self.extractClassInfo()
	
	def repairType(self, rawType):
		if (rawType.lower() == "byte"):
			return "int"
		elif (rawType.lower() == "int"):
			return "int"
		elif (rawType.lower() == "string"):
			return "String"
		elif (rawType.lower() == "short"):
			return "int"
		elif (rawType.lower() == "float"):
			return "Number"
		elif (rawType.lower() == "intarray"):
			return "Array"
		elif (rawType.lower() == "intarray2") or (rawType.lower() == "bytearray"):
			return "Array = []"
	def isSplitCase(self, rawString):
		return (rawString.find(';') > 0) and (rawString.find('$')<0) 
	def extractClassInfo(self):
		for i in range(len(self.type)):
			if self.type[i].find('array~') >=0:
				className = self.extractClassName(self.type[i])
				typeList = self.extractTypeName(self.type[i])
				variablesList = self.extractVariablesName(self.type[i])
				
				classInfo = ClassInfo()
				classInfo.className = className
				classInfo.typeList = typeList
				classInfo.variablesList = variablesList
				classInfo.relativeVariableName = self.name[i]
				self.mapClass[self.name[i]] = classInfo.className
				
				whetherContinue = False
				for name in self.classList:
					if name.className == className:
						whetherContinue = True
						break
				if whetherContinue:
					continue    #if the class has appeared in self.classList, just continue.
				self.classList.append(classInfo)   #store new classInfo for later use 		

				#print "typeList = ", typeList
				#print "variablesList = ", variablesList
				if len(typeList) != len(variablesList):
					print "encounter some error here. mark 1."
					return 
				serializeClass = '''/*
*
* Copyright 2016
* All rights reserved.
* This file is automatically generated by python script of which 
* the author is wupeng.
*
*/
'''
				serializeClass += "package staticdata.define\n{\n"
				serializeClass += "\tpublic class " + className + "\n\t{\n"
				for i in range(len(typeList)):
					serializeClass += "\t\tpublic var " + variablesList[i] + ":" + self.repairType(typeList[i]) + ";\n"
				serializeClass += "\n"
				serializeClass += "\t\tpublic function " + className + "("
				argumentsString = ""
				for i in range(len(typeList)):
					argumentsString += self.beautifyFormation(variablesList[i]) + ":" + self.repairType(typeList[i]) + " = 0, "
				serializeClass += argumentsString[:-2] + ")\n\t\t{\n"  #remove the last ', '
				initString = ""
				for i in range(len(typeList)):
					initString += "\t\t\tthis." + variablesList[i] + " = " + variablesList[i] + ";\n"
				serializeClass += initString + "\t\t}\n\t}\n}"
				serializeClass += '\n\n'
				
				slashLiteral = ''
				staticdataLiteral = ''
				defineLiteral = ''
				if os.name == 'nt':
					#windows system
					slashLiteral = '\\'
					staticdataLiteral = '\\staticdata\\'
					defineLiteral = '\\define\\'
				else:
					#unix or linux system
					slashLiteral = '/'
					staticdataLiteral = '/staticdata/'
					defineLiteral = '/define/'

				staticdataDir = self.destinationDir + staticdataLiteral
				if not os.path.exists(staticdataDir):
				    os.makedirs(staticdataDir)
				defineDir = staticdataDir + defineLiteral
				if not os.path.exists(defineDir):
				    os.makedirs(defineDir)
				classFileName = defineDir + slashLiteral + classInfo.className + '.as'
				fp = file(classFileName, 'wb')	
				fp.write(serializeClass)
				fp.close()
		
	def extractClassName(self, rawString):
		classNamePositin = rawString.find('~') + 1
		className = []
		for i in range(classNamePositin, len(rawString)):
			if (ord(rawString[i]) == 95) or ((ord(rawString[i]) >= 48) and (ord(rawString[i]) <=57)) or ((ord(rawString[i]) >= 65) and (ord(rawString[i]) <=90))  or ((ord(rawString[i]) >= 97) and (ord(rawString[i]) <=122)):
				className.append(rawString[i])
			else:
				break
		lst = [word[0].upper() + word[1:] for word in ''.join(className).split()]
		stringClassName = " ".join(lst)
		stringClassName = self.beautifyFormation(stringClassName)		
		return stringClassName
	def extractTypeName(self, rawString):
		tmpList = []
		typeList = []
		#it seems that the first type name always appears after '$' symble. 
		dollorPositon = rawString.find('$')
		typeName = []
		for i in range(dollorPositon + 1, len(rawString)):
			if ((ord(rawString[i]) >= 48) and (ord(rawString[i]) <=57)) or ((ord(rawString[i]) >= 65) and (ord(rawString[i]) <=90))  or ((ord(rawString[i]) >= 97) and (ord(rawString[i]) <=122)):
				typeName.append(rawString[i])
			else:
				tmpList.append(''.join(typeName))
				break
		#from the second type name, it seems that the type name always appears after ';' symble.
		#find all the position of semicolon in string name.
		semicolonPositinList = [m.start() for m in re.finditer(';', rawString)]
		#print "semicolonPositinList = ",semicolonPositinList
		for semicolonPositin in semicolonPositinList:
			typeName[:] = [] #clear content of typeName
			for j in range(semicolonPositin + 1, len(rawString)):
				if ((ord(rawString[j]) >= 48) and (ord(rawString[j]) <=57)) or ((ord(rawString[j]) >= 65) and (ord(rawString[j]) <=90)) or ((ord(rawString[j]) >= 97) and (ord(rawString[j]) <=122)):
					typeName.append(rawString[j])
				else:
					tmpList.append(''.join(typeName))
					break
					
		for rawType in tmpList:
			#typeList.append(self.repairType(rawType.lower()))
			typeList.append(rawType.lower())
		return typeList 
	#typeString has the form 'array~channel_type$short~map_id;int~x;int~y'
	def extractVariablesName(self, rawString):
		variablesList = []
		variableName = []
		wavePositionList = [m.start() for m in re.finditer('~', rawString)]
		for i in range(len(wavePositionList)):
			if i == 0:
				continue #the first ~ symble is just a mark for the form 'array~channel_type$short~map_id;int~x;int~y'
			variableName[:] = []
			for j in range(wavePositionList[i] + 1, len(rawString)):
				if (ord(rawString[j]) == 95) or ((ord(rawString[j]) >= 48) and (ord(rawString[j]) <=57)) or ((ord(rawString[j]) >= 65) and (ord(rawString[j]) <=90)) or ((ord(rawString[j]) >= 97) and (ord(rawString[j]) <=122)):
					variableName.append(rawString[j])
				else:
					break
			variablesList.append(self.beautifyFormation(''.join(variableName)))
		return variablesList
	def beautifyFormation(self, nameStr):
		indices = set([])
		for i,c in enumerate(nameStr):
			if "_"==c: indices.add(i+1)
		if (len(indices) == 0):
			return nameStr
		nameStr = "".join(c.upper() if i in indices else c for i, c in enumerate(nameStr))
		nameStr = nameStr.replace('_','')
		return nameStr
	def getType(self, colIndex):
		return self.type[colIndex]
	def getName(self, colIndex):
		return self.name[colIndex]
	def getDesc(self, colIndex):
		return self.desc[colIndex]
	def getColSize(self):
		return self.colSize
	def ConvertValue(self, lst):
		ret=[]
		for v in lst:
			data = v
			if isinstance(v, int):
				data = int(v)
			if isinstance(v, float):
				if v == int(v):
					data = int(v)
				else:
					data = float(v)
			if isinstance(v, unicode):
				data = v.encode("gbk")
			data=str(data)
			ret.append(data)
		return ret
	def excludeRepeatedCase(self, rawRow):
		d = dict()
		for i in range(len(rawRow)):
			if rawRow[i] in d:
				errStr = '!!!!!!!! ', 'repeated variable: ', rawRow[i], ' !!!!!!!!!!'
				print errStr
				time.sleep(1000)
				raise Exception(errStr)
			else:
				d[rawRow[i]] = 0
	def excludeBlankData(self, rawData, row):
		if rawData == '':
			errStr = '!!!!!!!! ', 'There is blank data in row ' + str(row), ' !!!!!!!!!!'
			print errStr
			time.sleep(1000)
			raise Exception(errStr)
		return

class ClassInfo:
	def __init__(self):
		self.className = ''
		self.typeList = []
		self.variablesList = []
		self.relativeVariableName = ''
#dat = Dat("/Users/leowu/test/source/StaticErrorCodeInfo.dat")
#dat = Dat("X:\\clientTools\\tools\\datFileDir\\scene_overall.dat", "X:\\clientTools\\tools\\asFileDir\\")
'''
print "---------------------"
for i in range(len(dat.name)):
	print dat.name[i]
print "---------------------"
for i in range(len(dat.type)):
	print dat.type[i]
print "---------------------"
for i in range(len(dat.desc)):
	print dat.desc[i]
print "---------------------"
print dat.classesSerialize
'''
