# encoding=utf8
import re
import os
import xlrd
import time


class ParseXls:
	def __init__(self, xls_path, dst_dir):
		self.xls_path = xls_path
		self.dst_dir = dst_dir
		self.staitc_file_name = ''
		self.colSize = 0
		self.rowSize = 0
		self.type = []
		self.name = []
		self.desc = []
		self.classList = []
		self.map_class = {}
		
		workbook = xlrd.open_workbook(self.xls_path)
		worksheet = workbook.sheet_by_index(0)
		row1 = self.convert_value(worksheet.row_values(0))
		row2 = self.convert_value(worksheet.row_values(1))
		row3 = self.convert_value(worksheet.row_values(2))
		row4 = self.convert_value(worksheet.row_values(3))
		row5 = self.convert_value(worksheet.row_values(4))
		
		self.exclude_repeated_case(row5)
		
		if row1[0] == '':
			err_str = '!!!!!!!! ', 'File name is nill!', ' !!!!!!!!!!'
			print err_str
			time.sleep(1000)
			raise Exception(err_str)
		self.staitc_file_name = row1[0]
		
		for i in range(len(row2)):
			if row2[i] == "1":
				str_name = row4[i].lower()
				#if str_name == "intarray" or str_name == "intarray2":
				#	str_name = "String"
				self.exclude_blank_data(row4[i], 4)
				self.exclude_blank_data(row5[i], 5)
				
				if self.is_split_case(str_name):
					type_list = str_name.split(';')
					variables_list = row5[i].split(';')
					if len(type_list) != len(variables_list):
						err_str = '!!!!!!!! ', 'encounter error here. mark 1', ' !!!!!!!!!!'
						print err_str
						time.sleep(1000)
						raise Exception(err_str)
					for j in range(len(type_list)):
						self.type.append(type_list[j])
						self.name.append(variables_list[j])
						self.desc.append(unicode(row3[i], 'gbk'))
				else:
					self.type.append(str_name)
					self.name.append(row5[i])
					self.desc.append(unicode(row3[i], 'gbk'))
		self.colSize = len(self.type)
		self.rowSize = worksheet.nrows - 5
			
		self.extract_class_info()
	
	def repair_type(self, raw_type):
		if raw_type.lower() == "byte":
			return "int"
		elif raw_type.lower() == "int":
			return "int"
		elif raw_type.lower() == "string":
			return "String"
		elif raw_type.lower() == "short":
			return "int"
		elif raw_type.lower() == "float":
			return "Number"
		elif raw_type.lower() == "intarray":
			return "Array"
		elif (raw_type.lower() == "intarray2") or (raw_type.lower() == "bytearray"):
			return "Array = []"

	def is_split_case(self, raw_string):
		return (raw_string.find(';') > 0) and (raw_string.find('$') < 0)

	def extract_class_info(self):
		for i in range(len(self.type)):
			if self.type[i].find('array~') >= 0:
				class_name = self.extract_class_name(self.type[i])
				type_list = self.extract_type_name(self.type[i])
				variables_list = self.extract_variables_name(self.type[i])
				
				class_info = ClassInfo()
				class_info.className = class_name
				class_info.typeList = type_list
				class_info.variablesList = variables_list
				class_info.relativeVariableName = self.name[i]
				self.map_class[self.name[i]] = class_info.className
				
				whether_continue = False
				for name in self.classList:
					if name.className == class_name:
						whether_continue = True
						break
				if whether_continue:
					continue    # if the class has appeared in self.classList, just continue.
				self.classList.append(class_info)   # store new class_info for later use

				# print "type_list = ", type_list
				# print "variables_list = ", variables_list
				if len(type_list) != len(variables_list):
					print "encounter some error here. mark 1."
					return 
				serialize_class = '''/*
*
* Copyright 2016
* All rights reserved.
* This file is automatically generated by python script of which 
* the author is wupeng.
*
*/
'''
				serialize_class += "package staticdata.define\n{\n"
				serialize_class += "\tpublic class " + class_name + "\n\t{\n"
				for i in range(len(type_list)):
					serialize_class += "\t\tpublic var " + variables_list[i] + ":" + self.repair_type(type_list[i]) + ";\n"
				serialize_class += "\n"
				serialize_class += "\t\tpublic function " + class_name + "("
				arguments_string = ""
				for i in range(len(type_list)):
					arguments_string += self.beautify_formation(variables_list[i]) + ":" + self.repair_type(type_list[i]) + " = 0, "
				serialize_class += arguments_string[:-2] + ")\n\t\t{\n"  #remove the last ', '
				init_string = ""
				for i in range(len(type_list)):
					init_string += "\t\t\tthis." + variables_list[i] + " = " + variables_list[i] + ";\n"
				serialize_class += init_string + "\t\t}\n\t}\n}"
				serialize_class += '\n\n'
				
				slash_literal = ''
				staticdata_literal = ''
				define_literal = ''
				if os.name == 'nt':
					# windows system
					slash_literal = '\\'
					staticdata_literal = '\\staticdata\\'
					define_literal = '\\define\\'
				else:
					# unix or linux system
					slash_literal = '/'
					staticdata_literal = '/staticdata/'
					define_literal = '/define/'

				staticdata_dir = self.dst_dir + staticdata_literal
				if not os.path.exists(staticdata_dir):
					os.makedirs(staticdata_dir)
				define_dir = staticdata_dir + define_literal
				if not os.path.exists(define_dir):
					os.makedirs(define_dir)
				class_file_name = define_dir + slash_literal + class_info.className + '.as'
				fp = file(class_file_name, 'wb')
				fp.write(serialize_class)
				fp.close()
		
	def extract_class_name(self, raw_string):
		class_name_positin = raw_string.find('~') + 1
		class_name = []
		for i in range(class_name_positin, len(raw_string)):
			if (ord(raw_string[i]) == 95) or ((ord(raw_string[i]) >= 48) and (ord(raw_string[i]) <=57)) or ((ord(raw_string[i]) >= 65) and (ord(raw_string[i]) <=90))  or ((ord(raw_string[i]) >= 97) and (ord(raw_string[i]) <=122)):
				class_name.append(raw_string[i])
			else:
				break
		lst = [word[0].upper() + word[1:] for word in ''.join(class_name).split()]
		string_class_name = " ".join(lst)
		string_class_name = self.beautify_formation(string_class_name)
		return string_class_name

	def extract_type_name(self, raw_string):
		tmp_list = []
		type_list = []
		# it seems that the first type name always appears after '$' symble.
		dollor_positon = raw_string.find('$')
		type_name = []
		for i in range(dollor_positon + 1, len(raw_string)):
			if ((ord(raw_string[i]) >= 48) and (ord(raw_string[i]) <=57)) or ((ord(raw_string[i]) >= 65) and (ord(raw_string[i]) <=90))  or ((ord(raw_string[i]) >= 97) and (ord(raw_string[i]) <=122)):
				type_name.append(raw_string[i])
			else:
				tmp_list.append(''.join(type_name))
				break
		semicolon_positin_list = [m.start() for m in re.finditer(';', raw_string)]
		for semicolonPositin in semicolon_positin_list:
			type_name[:] = []
			for j in range(semicolonPositin + 1, len(raw_string)):
				if ((ord(raw_string[j]) >= 48) and (ord(raw_string[j]) <=57)) or ((ord(raw_string[j]) >= 65) and (ord(raw_string[j]) <=90)) or ((ord(raw_string[j]) >= 97) and (ord(raw_string[j]) <=122)):
					type_name.append(raw_string[j])
				else:
					tmp_list.append(''.join(type_name))
					break
					
		for rawType in tmp_list:
			type_list.append(rawType.lower())
		return type_list

	def extract_variables_name(self, raw_string):
		variables_list = []
		variable_name = []
		wave_position_list = [m.start() for m in re.finditer('~', raw_string)]
		for i in range(len(wave_position_list)):
			if i == 0:
				continue #the first ~ symble is just a mark for the form 'array~channel_type$short~map_id;int~x;int~y'
			variable_name[:] = []
			for j in range(wave_position_list[i] + 1, len(raw_string)):
				if (ord(raw_string[j]) == 95) or ((ord(raw_string[j]) >= 48) and (ord(raw_string[j]) <=57)) or ((ord(raw_string[j]) >= 65) and (ord(raw_string[j]) <=90)) or ((ord(raw_string[j]) >= 97) and (ord(raw_string[j]) <=122)):
					variable_name.append(raw_string[j])
				else:
					break
			variables_list.append(self.beautify_formation(''.join(variable_name)))
		return variables_list

	def beautify_formation(self, name_str):
		indices = set([])
		for i, c in enumerate(name_str):
			if "_" == c:
				indices.add(i+1)
		if len(indices) == 0:
			return name_str
		name_str = "".join(c.upper() if i in indices else c for i, c in enumerate(name_str))
		name_str = name_str.replace('_', '')
		return name_str

	def get_type(self, col_index):
		return self.type[col_index]

	def get_name(self, col_index):
		return self.name[col_index]

	def get_desc(self, col_index):
		return self.desc[col_index]

	def get_col_size(self):
		return self.colSize

	def convert_value(self, lst):
		ret = []
		for v in lst:
			data = v
			if isinstance(v, int):
				data = int(v)
			if isinstance(v, float):
				if v == int(v):
					data = int(v)
				else:
					data = float(v)
			if isinstance(v, unicode):
				data = v.encode("gbk")
			data = str(data)
			ret.append(data)
		return ret

	def exclude_repeated_case(self, raw_row):
		d = dict()
		for i in range(len(raw_row)):
			if raw_row[i] in d:
				err_str = '!!!!!!!! ', 'repeated variable: ', raw_row[i], ' !!!!!!!!!!'
				print err_str
				time.sleep(1000)
				raise Exception(err_str)
			else:
				d[raw_row[i]] = 0

	def exclude_blank_data(self, raw_data, row):
		if raw_data == '':
			err_str = '!!!!!!!! ', 'There is blank data in row ' + str(row), ' !!!!!!!!!!'
			print err_str
			time.sleep(1000)
			raise Exception(err_str)
		return


class ClassInfo:
	def __init__(self):
		self.className = ''
		self.typeList = []
		self.variablesList = []
		self.relativeVariableName = ''
# dat = Dat("/Users/leowu/test/source/StaticErrorCodeInfo.dat")
# dat = Dat("X:\\clientTools\\tools\\datFileDir\\scene_overall.dat", "X:\\clientTools\\tools\\asFileDir\\")
'''
print "---------------------"
for i in range(len(dat.name)):
	print dat.name[i]
print "---------------------"
for i in range(len(dat.type)):
	print dat.type[i]
print "---------------------"
for i in range(len(dat.desc)):
	print dat.desc[i]
print "---------------------"
print dat.classesSerialize
'''
