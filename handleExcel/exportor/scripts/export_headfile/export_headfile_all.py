# encoding=utf8
import os
import struct
import sys
import json
import string
import ParseXls
import shutil
import time

reload(sys)  
sys.setdefaultencoding('utf8')

XLS_DIR=""
CPP_DIR=""

def initPath():
	global XLS_DIR
	global CPP_DIR
	XLS_DIR = checkPath(sys.argv[1])
	CPP_DIR = checkPath(sys.argv[2])

def checkPath(path):
        if os.name == 'nt': #windows os
            ok = path.endswith('\\')
            if ~ok:
                return path + '\\'
            return path
        else:              #unix or linux
            ok = path.endswith('/')
            if ~ok:
                return path + '/'
            return path

def refreshFolder(directory):
	if os.path.exists(directory):
		shutil.rmtree(directory)
	os.makedirs(directory)

class GenerateCppFromXls:
	def tackleEveryFile(self):
		for filename in os.listdir(XLS_DIR):
			if ((filename[-3:] != 'xls') and (filename[-4:] != 'xlsx')) or (filename[0] == '~'):
				continue
			self.generate(filename)
	
	def generate(self, xlsFileName):
		print xlsFileName
		xlsFilePathName = XLS_DIR + xlsFileName
		parseXls = ParseXls.ParseXls(xlsFilePathName)	
		cppFilePathName = CPP_DIR + parseXls.staitcFileName + ".h"
		
		cppFile = file(cppFilePathName, "wb")
		contentStr = '''/*
*
* Copyright 2016
* All rights reserved.
* This file is automatically generated by python script of which 
* the author is wupeng.
*
*/
'''
		contentStr += '''
#pragma once

#include <lib_file_tab_txt.h>
#include <lib_util.h>

namespace '''
		contentStr += parseXls.staitcFileName + "_auto{\n"
		contentStr += parseXls.serializeStructs + '\n'
			
		contentStr += '\tstruct ' + parseXls.staitcFileName + '_cfg_t\n\t{\n'
		
		for i in range(0, parseXls.getColSize()):
			typeStr = parseXls.getType(i)
			nameStr = parseXls.getName(i)
			#print 'i = ', i
			#print 'nameStr = ', nameStr
			#print 'parseXls.getDesc(i) = ', parseXls.getDesc(i)
			#print '\n'
			descStr = parseXls.getDesc(i).replace('\n','')
			
			if typeStr.find('array~') == 0:
				continue
			elif typeStr.lower() == 'intarray' or typeStr.lower() == 'bytearray':
				contentStr += '\t\tstd::vector<uint32_t> ' + nameStr + ';' + "\t\t//" + descStr + "	\n"
			elif typeStr.lower() == 'intarray2':
				contentStr += '\t\tstd::vector<std::vector<uint32_t>> ' + nameStr + ';' + "\t\t//" + descStr + "	\n"
			else:
				typeStr = self.getRepairedType(typeStr.lower())
				contentStr += "\t\t" + typeStr + " " + nameStr + ";" + "\t\t//" + descStr + "	\n"
		
		for relativeVariableName, relativeStructName in parseXls.mapStruct.iteritems():  #for python 2.x
			structInfo = self.getSpecificStructInfo(parseXls, relativeStructName)
			contentStr += "\t\tstd::vector<" + relativeStructName + "_t> " +  relativeVariableName + ";" + "\t\t//" + structInfo.desc + "	\n" 
			
		contentStr += '\n'
		contentStr += '\t\tvoid load(el::lib_file_tab_txt_t& file_tab_txt, std::vector<std::string>& ref){\n'
		contentStr += '\t\t\tstd::string __str_def__;\n\n'
		
		
		for i in range(0, parseXls.getColSize()):
			typeStr = parseXls.getType(i)
			nameStr = parseXls.getName(i)
			#descStr = parseXls.getDesc(i)

			if typeStr.lower().find('array~') == 0:
				structName = self.extractStructName(typeStr)
				for relativeVariableName, relativeStructName in parseXls.mapStruct.iteritems():  #for python 2.x
					if nameStr == relativeVariableName:
						structInfo = self.getSpecificStructInfo(parseXls, relativeStructName)
						contentStr += '\t\t\t{\n'
						contentStr += '\t\t\t\t' + 'std::string str_array = file_tab_txt.get_val_def(\"' + relativeVariableName + '\", ref, ' + '__str_def__);\n'
						#contentStr += "\t\t\t\t" + "std::vector<std::vector<std::string>> para_vec;\n"
						contentStr += '\t\t\t\t' + 'auto para_vec = el::g_cat_string<std::string>(' + 'str_array, \';\', \'_\');\n\n'
						contentStr += "\t\t\t\t" + "FOREACH(para_vec, it){\n"
						contentStr += '\t\t\t\t\t' + relativeStructName + '_t ' + relativeStructName + ';\n'
						contentStr += '\t\t\t\t\t' + 'std::vector<std::string>& u_vec = *it;\n'
						
						for i in range(len(structInfo.variablesList)):
							contentStr += "\t\t\t\t\t" + 'el::convert_from_string(' + relativeStructName + '.' + structInfo.variablesList[i] + ', u_vec[' + str(i) + ']);\n'						
						contentStr += "\t\t\t\t\t" + 'this->' + relativeVariableName + '.push_back(' + relativeStructName + ');\n'
						contentStr += '\t\t\t\t}\n\t\t\t}\n'
			elif typeStr.lower() == 'intarray':
				contentStr += '\t\t\t{\n' 
				contentStr += '\t\t\t\t' + 'std::string array = file_tab_txt.get_val_def(\"' + nameStr + '\"' + ', ref, __str_def__);\n'
				contentStr += '\t\t\t\t' + 'el::g_cat_string(this->' + nameStr + ', array, \'_\');\n'
				contentStr += '\t\t\t}\n'
			elif typeStr.lower() == 'intarray2':
				contentStr += '\t\t\t{\n' 
				contentStr += '\t\t\t\t' + 'std::string array = file_tab_txt.get_val_def(\"' + nameStr + '\"' + ', ref, __str_def__);\n'
				contentStr += '\t\t\t\t' + 'this->' + nameStr + ' = el::g_cat_string<uint32_t>(array, \';\', \'_\');\n'
				contentStr += '\t\t\t}\n'
			elif typeStr.lower() == 'string':
				contentStr += "\t\t\t" + 'this->' + nameStr + '= file_tab_txt.get_val_def(\"' + nameStr + '\", ref, __str_def__);\n'
			else:
				contentStr += "\t\t\t" + 'this->' + nameStr + '= file_tab_txt.get_val_def(\"' + nameStr + '\", ref, 0);\n'
				
		contentStr = contentStr.strip('\n')
		contentStr += "\t\t\n\t\t}\n" + "\t};\n" + "}\n"

		cppFile.write(contentStr)
		cppFile.close()
		
	def extractStructName(self, rawString):
		structNamePositin = rawString.find('~') + 1
		structName = []
		for i in range(structNamePositin, len(rawString)):
			if (ord(rawString[i]) == 95) or ((ord(rawString[i]) >= 48) and (ord(rawString[i]) <=57)) or ((ord(rawString[i]) >= 65) and (ord(rawString[i]) <=90))  or ((ord(rawString[i]) >= 97) and (ord(rawString[i]) <=122)):
				structName.append(rawString[i])
			else:
				break
		lst = [word[0].upper() + word[1:] for word in ''.join(structName).split()]
		stringStructName = " ".join(lst)
		stringStructName = stringStructName
		return stringStructName
	def getRepairedType(self, rawType):
		if (rawType.lower() == "byte"):
			return "uint8_t"
		elif (rawType.lower() == "int"):
			return "uint32_t"
		elif (rawType.lower() == "string"):
			return "std::string"
		elif (rawType.lower() == "short"):
			return "uint16_t"
		elif (rawType.lower() == "float"):
			return "double"
	def getSpecificStructInfo(self, parseXls, structName):
		for structInfo in parseXls.structList:
			if structInfo.structName == structName:
				return structInfo
		return ''
	def pause(self):
		raw_input_A = raw_input("Generate successfully! Press any key to exit!")
		
if __name__ == "__main__":
    print '--------------Convert excel to header file---------------'
    initPath()
    refreshFolder(CPP_DIR)
    generater = GenerateCppFromXls()
    generater.tackleEveryFile()
    #generater.pause()
